## 알고리즘

[단속카메라](https://programmers.co.kr/learn/courses/30/lessons/42884)

- 그리디 알고리즘.
- 2차원 배열의 정렬에 있어서 기준을 어느 값으로 잡냐에 따라 풀이 효율이 달라짐.

## CS

### 객체지향 
    - SOLID 5원칙:
        - 단일 책임: 하나의 모듈은 하나의 책임을 가진다. -> 모듈의 변경되는 이유는 한가지.
        - 개방 폐쇄: 확장에 대해 열려있고(새 동작 추가 가능) 수정에 대해서는 닫혀있어야 한다(기존의 코드를 수정하지 않고). 
        - 리스코프 치환: 하위 타입은 상위 타입을 대체할수 있음. Map<T> map = new HashMap<>();
        - 인터페이스 분리: 클라이언트의 목적과 관심이 다르면 의존하는 인터페이스 또한 분리되어야 한다.
        - 의존 관계 역전: 객체는 저수준 모듈보다 고수준 모듈에 의존해야 한다. 객체보다는 인터페이스로 선언하라.
    - OOP 4특징:
        - 추상화: 사물(객체) 들의 공통적인 특징을 추출.
        - 상속: 상위개념의 특징을 하위개념이 물려받음. 클래스의 상속.
        - 캡슐화(은닉성): 데이터 구조와 기능을 결합하여 묶고, 데이터 자체는 외부로 노출시키지 않는다.
        - 다형성: 오버라이딩/오버로딩 과 같이 하나의 메소드나 클래스가 다양한 방법으로 동작하는 것.

### Java의 ArrayList & LinkedList
    - 정의: 
        - ArrayList는 사실상 그냥 배열 + pop,push,insert,delete,indexing 등의 기능을 구현해 둔 것.
        - Linkedlist는 head,tail의 포인터로 각 요소(노드)들이 연결되어 있는 것. 양방향 연결 리스트.
    
    - 장단점
        - ArrayList는 비순차적인 데이터의 추가 또는 삭제에 O(n)의 시간 복잡도 발생.
        - ArrayList는 인덱스를 통해 간편히 중간 요소에 접근.
        - LinkedList는 인덱싱이 힘들다.
        - LinkedList는 비순차적인 데이터의 수정에 유리하다. 포인터 부분만 변경.
        - ArrayList는 조회에 유리하고, LinkedList는 동적인 수정에 유리하다.


## 과제

- https://programmers.co.kr/learn/courses/30/lessons/70130

- CS 1문제 준비


